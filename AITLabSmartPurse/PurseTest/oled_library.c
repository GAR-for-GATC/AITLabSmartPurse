/*
	This oled library is a modified version of the Adafruit_SSD1306 library, modified to run
without the arduino tookkit, which is super fucking bloated.  Also changed the file type from 
cpp to just .c
*/



#include "include.h"
#include <string.h>


// the memory buffer for the LCD
/*
static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
	0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
	#if (SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH > 96*16)
	0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
	0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
	0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
	0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
	0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
	0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
	0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
	0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
	0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
	0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
	0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
	0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
	0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	#if (SSD1306_LCDHEIGHT == 64)
	
	0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
	0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
	
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
	//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,

	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
	0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
	0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
	0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
	
	0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
	0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
	
	0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
	0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
	0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
	0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
	
	0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	#endif
	#endif
};

*/
static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {0};
	/*
	{
	*/
	/*
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	*/
	/*
	//  i <3 
	0x00, 0x41, 0x41, 0x7F, 0x7F, 0x41, 0x41, 0x00, 0x08, 0x1C, 0x36, 0x22, 0x00, 0b00100010, 0b01100011, 0b01000001,
	// 3 Ev
	0b01001001, 0b01001001, 0b01111111, 0b00110110, 0x00, 0b01111111, 0b01111111, 0b01001001, 0b01001001, 
				0b01001001, 0b01001001, 0b01000001, 0x00, 0b00111000, 0b01111000, 0b11000000,
	// vee
	0b10000000, 0b11000000, 0b01111000, 0b01111000, 0x00,
	0b01110000, 0b11111000, 0b10101000, 0b10101000, 0b10101000, 0b10111000, 0b00110000, 0x00,
	0b01110000, 0b11111000, 0b10101000,
	
	0b10101000, 0b10101000, 0b10111000, 0b00110000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 
	
	0x00, 0x41, 0x41, 0x7F, 0x7F, 0x41, 0x41, 0x00, 0x08, 0x1C, 0x36, 0x22, 0x00, 0b00100010, 0b01100011, 0b01000001,
	// 3 Ev
	0b01001001, 0b01001001, 0b01111111, 0b00110110, 0x00, 0b01111111, 0b01111111, 0b01001001, 0b01001001,
	0b01001001, 0b01001001, 0b01000001, 0x00, 0b00111000, 0b01111000, 0b11000000,
	// vee
	0b10000000, 0b11000000, 0b01111000, 0b01111000, 0x00,
	0b01110000, 0b11111000, 0b10101000, 0b10101000, 0b10101000, 0b10111000, 0b00110000, 0x00,
	0b01110000, 0b11111000, 0b10101000,
	
	0b10101000, 0b10101000, 0b10111000, 0b00110000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00,
	*/
	/*
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
};
*/


//I <3 evee
	//bitmap is:
	/*
	0 0 1 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 1 1 0 0 0 0 0 1 1 0 1 1 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 1 1 1 1 1 0 0 0 1 1 1 1 1 0
	0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 0 0 1 1 0 0 0 1 1 0 1 1 0 0 0 1 1 0 1 1 0 0 0 1 1
	0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 1 1 0 0 0 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
	0 0 0 0 1 1 0 0 0 0 0 1 1 0 1 1 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 1 0 1 1 0 0 1 1 0 0 0 0 0 0 1 1 0 0 0 0 0
	0 0 1 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 1 1 1 1 0 0 0 1 1 1 0 0 0 0 1 1 1 1 1 0 0 0 1 1 1 1 1 0
	
	*/


//last number is the number of characters used, since C cant find the sizeof an array if you pass a pointer...
static uint8_t space[] = {0x00, 1};
static uint8_t capI[] = {
	0x41, 0x41, 0x7F,  0x7F, 0x41, 0x41, 6
};
static uint8_t lessThan[] = {
	0x08, 0x1C, 0x36, 0x22, 4 
};
static uint8_t three[] = {
	0b00100010, 0b01100011, 0b01000001, 0b01001001, 0b01001001, 0b01111111, 0b00110110
};
static uint8_t capE[] = {
	0b01111111, 0b01111111, 0b01001001, 0b01001001, 0b01001001, 0b01001001, 0b01000001, 7
};
static uint8_t lowerv[] = {
	0b00011100, 0b00011110, 0b00000011, 0b00000001, 0b00000011, 0b00011110, 0b0001110, 7
};
static uint8_t lowere[] = {
	0b00001110, 0b00011111, 0b00010101, 0b00010101, 0b00010101, 0b00011101, 0b00001100, 7
};


//using this font:
//https://www.fontspace.com/font-charmap/28254
//numbers
//static uint8_t number1[]={0b00100000, 0b01111111};
static uint8_t number1[]={0b00000100, 0b11111110, 0b00000000};
//static uint8_t number2[]={0b00100001, 0b01000011, 0b01000101, 0b01001001, 0b00110001};
static uint8_t number2[]={0b10000100, 0b11000010, 0b10100010, 0b10010010, 0b10001100, 0b00000000};
//static uint8_t number3[]={0b00100010, 0b01000001, 0b01001001, 0b01001001, 0b00110110};
static uint8_t number3[]={0b01000100, 0b10000010, 0b10010010, 0b10010010, 0b01101100, 0b00000000};
//static uint8_t number4[]={0b00001100, 0b00010100, 0b00100100, 0b01111111, 0b00000100};
static uint8_t number4[]={0b00110000, 0b00101000, 0b00100100, 0b11111110, 0b00100000, 0b00000000};
//static uint8_t number5[]={0b01111001, 0b01001001, 0b01001001, 0b01001001, 0b01000110};
static uint8_t number5[]={0b10011110, 0b10010010, 0b10010010, 0b10010010, 0b01100010, 0b00000000};
//static uint8_t number6[]={0b00011110, 0b00101001, 0b01001001, 0b01001001, 0b00000110};
static uint8_t number6[]={0b01111000, 0b10010100, 0b10010010, 0b10010010, 0b01100000, 0b00000000};
//static uint8_t number7[]={0b01000000, 0b01000000, 0b01000111, 0b01011000, 0b01100000};
static uint8_t number7[]={0b00000010, 0b00000010, 0b11100010, 0b00011010, 0b00000110, 0b00000000};
//static uint8_t number8[]={0b00110110, 0b01001001, 0b01001001, 0b01001001, 0b00110110};
static uint8_t number8[]={0b01101100, 0b10010010, 0b10010010, 0b10010010, 0b01101100, 0b00000000};
//static uint8_t number9[]={0b00110000, 0b01001001, 0b01001001, 0b01001010, 0b00111100};
static uint8_t number9[]={0b00001100, 0b10010010, 0b10010010, 0b01010010, 0b00111100, 0b00000000};
//static uint8_t number0[]={0b00111110, 0b01000101, 0b01001001, 0b01010001, 0b00111110};
static uint8_t number0[]={0b01111100, 0b10100010, 0b10010010, 0b10001010, 0b01111100, 0b00000000};

//decimal place
static uint8_t decimalPlace[]={0b00000000, 0b01000000,0b00000000};

//SpinningIcon: - \ | / - \ | /-
static uint8_t minusSign[]={0b00000000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00000000};

/*
static uint8_t iheartevee[] = 
	space + space + capI + space + lessThan + space + three + space + capE + space + 
	lowerv + space + lowere + space + lowere;
*/
void ssd1306_command(uint8_t c){
	uint8_t address = 0b01111000;   
	//Wire.beginTransmission(_i2caddr);
	//Wire.write(control);
	//Wire.write(c);
	//Wire.endTransmission();
	
	twiStart();
	//if(twiGetStatus() != 0x18){
		//return error.
	//}
	twiWrite(address); //send address, '0111100' and add a '0' for write.
						// '0011 1100', or 0x3C
	twiWrite(0x00);					
	twiWrite(c);
	twiStop();
};



/*
char *ptr = (char*) return_partition;
uint8_t* block_ptr =(uint8_t *) Read_and_Write;
for (i=0; i<16; i++){
	*ptr = *(block_ptr + 446 + i);	//The first 446 bytes in the MBR are boot code, the next 64 bytes
	++ptr;							//	are for partition data.  Every 16 bytes describes one partition.
}

*/

//add the elements of an array of array pointers to the buffer
void bufferAdd(uint8_t **array_of_pointers[], uint8_t *buffer){
	int counter = 0;
	for(int i=0; i< (sizeof(array_of_pointers) / sizeof(uint8_t)); i++ ){
		uint8_t *a = *(array_of_pointers + i); // gets the value or the pointer
		
		for(int j=0; j< a[-1]; j++){
			buffer[counter] = array_of_pointers[i][j];
			
			counter++;
		}
	}
	//fill with zeros
	int counter2 = counter;
	if(counter < ((SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT)/8)){
		for(uint8_t i=(((SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT)/8)-counter); i > 0; i--){
			buffer[counter2] = 0x00;
			counter2++;
		}
	}
}

void initDisplay(void) {
	//printString("cocks");
	_delay_ms(3); //delay 3us for screen startup
	
	//ssd1306 startup sequence: 
	/*
	1) Set MUX ratio
	2) Set display offset
	3) Set display start line
	4) Set segment remap
	5) Set COM output scan direction
	6) Set COM pins hardware configuration.
	7) Set contrast control.
	8) Disable entire display on
	9) Set normal display
	10) Set Osc frequency.
	11) enable charge pump regulator.
	12) turn display on.
	
	Pin D2 and D1 are tied together to form SDL, D2 is an output, D1 is an input.
	D0 is the SCL.
	Write address : b0111100 + the write bit 0.
	When writing, send control byte first, then the data byte next.
		The control byte starts with the Continuation bit, 
		 and then the Data/Command selection bit.  Then its 
		 followed by a 5 bits .
		 
	Detail steps:
	1) sent start signal.
	2) send address.  MSB is always shifted out first in I2C, so the address + bit would be: 
		0b01111000.
	3) if the next packet has a Co bit set to '0', then the following packets are just data
		bytes.  If it's '1' then the command always has command packets interspersed.
		In this step send a data packet of all zeros.
	4)
	
	
	
	*/
	
	//Rest for 15ms
	_delay_ms(15);
	
	
	// Init sequence
	ssd1306_command(SSD1306_DISPLAYOFF);                    // 0xAE
	ssd1306_command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5, 1101 0101 
	ssd1306_command(0x80);                                  // the suggested ratio 0x80 //set mux ratio?

	ssd1306_command(SSD1306_SETMULTIPLEX);                  // 0xA8// this is the mux ratio
	ssd1306_command(SSD1306_LCDHEIGHT - 1);

	ssd1306_command(SSD1306_SETDISPLAYOFFSET);              // 0xD3 //this is default offset, vertical shift
	ssd1306_command(0x0);                                   // no offset
	ssd1306_command(SSD1306_SETSTARTLINE | 0x0);            // line #0 //display line start register.
	ssd1306_command(SSD1306_CHARGEPUMP);                    // 0x8D //next command enables/disables charge pump.
	//if (vccstate == SSD1306_EXTERNALVCC)
	//{ ssd1306_command(0x10); }
	//else
	{ ssd1306_command(0x14); }								//enable charge pump.
															//charge pump is a dc/dc voltage converter.  very efficient.
															//creates 7.5V to the oled driver block.
															
	ssd1306_command(SSD1306_MEMORYMODE);                    // 0x20 //3 memory address schemes.  currently in
															//Page Addressing Mode.
															
	ssd1306_command(0x00);                                  // 0x0 act like ks0108??
	ssd1306_command(SSD1306_SEGREMAP | 0x1);				// 0xA0 | 0x01, column address 127 mapped to SEG0.
	ssd1306_command(SSD1306_COMSCANDEC);					//0xC8, set scan direction to remap mode.
															//Scan from COM[N-1] to COM0 Where N is the Multiplex ratio
	
	#if defined SSD1306_128_32
	ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA
	ssd1306_command(0x02);
	ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81
	ssd1306_command(0x8F);

	#elif defined SSD1306_128_64
	ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA set com pins
	ssd1306_command(0x12);									//???
	ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81 two byte command.  contrast increases as value
															//increases.  feel free to set this to change contrast.
	//if (vccstate == SSD1306_EXTERNALVCC)
	//{ ssd1306_command(0x9F); }
	//else
	{ ssd1306_command(0xCF); }

	#elif defined SSD1306_96_16
	ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA
	ssd1306_command(0x2);   //ada x12
	ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81
	//if (vccstate == SSD1306_EXTERNALVCC)
	//{ ssd1306_command(0x10); }
	//else
	{ ssd1306_command(0xAF); }

	#endif
	ssd1306_command(SSD1306_SETPRECHARGE);                  // 0xd9 //precharge period
	//if (vccstate == SSD1306_EXTERNALVCC)
	//{ ssd1306_command(0x22); }
	//else
	{ ssd1306_command(0xF1); }
	ssd1306_command(SSD1306_SETVCOMDETECT);                 // 0xDB //set Vcomh deselect level.
	ssd1306_command(0x40);									// set to 0.77 * Vcc
	ssd1306_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4 Turn entire display on.
	ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6 set normal display, instead of inverse display

	ssd1306_command(SSD1306_DEACTIVATE_SCROLL);				//no scroll

	_delay_ms(1000);
	ssd1306_command(SSD1306_DISPLAYON);//--turn on oled panel
	_delay_ms(1000);

	///End of initialization.
	
	
	
	/*
	_delay_ms(5000);
	clearBuffer();
	//add letters to buffer
	uint8_t *array_of_pointers = { &space, &space, &capI, &space, &lessThan, &space, &three, &space, &capE, &space,
		&lowerv, &space, &lowere, &space, &lowere;}
	bufferAdd(array_of_pointers, &buffer);
	
	
	
	//add l
	for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
		//
		//printNumber16(i, 0);
		//newLine();
		// send a bunch of data in one xmission
		//Wire.beginTransmission(_i2caddr);
		twiStart();
		//aaa
		uint8_t myaddress = 0b01111000;
		twiWrite(myaddress); //send slave address, which is 0111100, then add a 0 at the front for write
		//WIRE_WRITE(0x40);
		twiWrite(0x40); //set display start line
		for (uint8_t x=0; x<16; x++) {
			twiWrite(buffer[i]);
			
			
			i++;
		}
		i--;
		//Wire.endTransmission();
		twiStop();
	}
	*/
	
}


void refreshDisplay(){
	ssd1306_command(SSD1306_COLUMNADDR); //0x21
	ssd1306_command(0);   // Column start address (0 = reset)
	
	
	ssd1306_command(SSD1306_LCDWIDTH-1); // Column end address (127 = reset)

	ssd1306_command(SSD1306_PAGEADDR); //0x22
	ssd1306_command(0); // Page start address (0 = reset)
	#if SSD1306_LCDHEIGHT == 64
	ssd1306_command(7); // Page end address
	#endif
	#if SSD1306_LCDHEIGHT == 32
	ssd1306_command(3); // Page end address
	#endif
	#if SSD1306_LCDHEIGHT == 16
	ssd1306_command(1); // Page end address
	#endif

	
	//printString("cocks2");

	//Serial.println(TWBR, DEC);
	//Serial.println(TWSR & 0x3, DEC);

	// I2C
	for (uint16_t i=0; i<(sizeof(buffer)); i++) {

		twiStart();
		//aaa
		uint8_t myaddress = 0b01111000;
		twiWrite(myaddress); //send slave address, which is 0111100, then add a 0 at the front for write
		//WIRE_WRITE(0x40);
		twiWrite(0x40); //set display start line
		twiWrite(buffer[i]);
		//printString("rawr");
		//printBinaryByte(buffer[i]);
		//newLine();
		/*
		for (uint8_t x=0; x<16; x++) {
			twiWrite(buffer[i]);
			
			i++;
		}
		i--;*/
		//Wire.endTransmission();
		twiStop();
	}
}

void clearDisplayBuffer(){
	//memset(&buffer, 0, 100);
	memset(buffer, 0, (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8)); //changes all bits to 0
}
/*
void clearBuffer(void){
	
}*/

void testDisplay(){
	memset(&buffer, 0b01010101, SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8);
}



void simpleLinePrint(char myString[], uint16_t sizeOfString){
	uint16_t positionCounter = 0;
	for(uint16_t i=0; i<sizeOfString; i++){
		/*
		if(myString[i] == '1'){
			for(uint8_t j=0; j<sizeof(three); j++){
				buffer[positionCounter+j] = number1[j];
			}
			positionCounter = positionCounter + sizeof(number1);
		}*/
		//printString("rawr");
		//printNumber((uint8_t) sizeof(myString));
		//newLine();
		switch(myString[i]){
			case '1':
				for(uint8_t j=0; j<sizeof(number1); j++){
					buffer[positionCounter+j] = number1[j];
				}
				positionCounter = positionCounter + sizeof(number1);
				continue;
			case '2':
				for(uint8_t j=0; j<sizeof(number2); j++){
					buffer[positionCounter+j] = number2[j];
				}
				positionCounter = positionCounter + sizeof(number2);
				continue;
			case '3':
				for(uint8_t j=0; j<sizeof(number3); j++){
					buffer[positionCounter+j] = number3[j];
				}
				positionCounter = positionCounter + sizeof(number3);
				continue;
			case '4':
				for(uint8_t j=0; j<sizeof(number4); j++){
					buffer[positionCounter+j] = number4[j];
				}
				positionCounter = positionCounter + sizeof(number4);
				continue;
			case '5':
				for(uint8_t j=0; j<sizeof(number5); j++){
					buffer[positionCounter+j] = number5[j];
				}
				positionCounter = positionCounter + sizeof(number5);
				continue;
			case '6':
				for(uint8_t j=0; j<sizeof(number6); j++){
					buffer[positionCounter+j] = number6[j];
				}
				positionCounter = positionCounter + sizeof(number6);
				continue;
			case '7':
				for(uint8_t j=0; j<sizeof(number7); j++){
					buffer[positionCounter+j] = number7[j];
				}
				positionCounter = positionCounter + sizeof(number7);
				continue;
			case '8':
				for(uint8_t j=0; j<sizeof(number8); j++){
					buffer[positionCounter+j] = number8[j];
				}
				positionCounter = positionCounter + sizeof(number8);
				continue;
			case '9':
				for(uint8_t j=0; j<sizeof(number9); j++){
					buffer[positionCounter+j] = number9[j];
				}
				positionCounter = positionCounter + sizeof(number9);
				continue;
			case '0':
				for(uint8_t j=0; j<sizeof(number0); j++){
					buffer[positionCounter+j] = number0[j];
				}
				positionCounter = positionCounter + sizeof(number0);
				continue;
			case '.':
				for(uint8_t j=0; j<sizeof(decimalPlace); j++){
					buffer[positionCounter+j] = decimalPlace[j];
				}
				positionCounter = positionCounter + sizeof(decimalPlace);
				continue;
			case '-':
				for(uint8_t j=0; j<sizeof(minusSign); j++){
					buffer[positionCounter+j] = minusSign[j];
				}
				positionCounter = positionCounter + sizeof(minusSign);
				continue;
		}
		
	}
}

//This function prints a line and moves the old lines to the next row.
//Each line is around 20 digits long, 128 pixels.
/*
Pseudocode:
delete last 128 places, then move all things before it 128 places,
then add new line.
*/
void multilineScrollPrint(char myString[], uint16_t sizeOfString){
	for(int i = 0; i<128; i++){
		buffer[(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8)-i] = 0b00000000;
	}	
	for(int i=((SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8)-129); i>=0; i--){
		buffer[i+128] = buffer[i];
	}
	for(int i = 0; i<128; i++){
		buffer[i] = 0b00000000;
	}
	simpleLinePrint(myString, sizeOfString);
}


//converts a float to a char array
//code modified from:
//source: https://stackoverflow.com/questions/23191203/convert-float-to-string-without-sprintf
//This function does not round.
char * floatToString(float x, char *p, uint8_t decimalPlaces) {
	//print64BitNumber((uint64_t)(x * 10000) % 10000);
	//newLine();
	char *s = p + 30; // go to end of buffer
	uint32_t decimals;  // variable to store the decimals
	uint32_t units;  // variable to store the units (part to left of decimal place)
	uint16_t a;
	if(decimalPlaces == 1){
		a=10;
	}else if(decimalPlaces == 2){
		a=100;
	}else if(decimalPlaces == 3){
		a=1000;
	}else if(decimalPlaces == 4){
		a=10000;
	}else{
		//no decimals
		a = 1;
	}
	
	if (x < 0) { // take care of negative numbers
		if(decimalPlaces != 0){
			decimals = (uint32_t)(x * a * -1) % a; // make 1000 for 3 decimals etc.
		}		
		units = (uint32_t)(-1 * x);
	} else { // positive numbers
		if(decimalPlaces != 0){
			decimals = (uint32_t)(x * a) % a;
		}		
		units = (uint32_t)x;
	}
	/*
	newLine();
	print32BitNumber(decimals); 
	newLine();
	print32BitNumber(decimals%10);
	newLine();
	print32BitNumber(decimals/10);
	newLine();	
	print32BitNumber((decimals/10)%10);
	newLine();
	print32BitNumber(decimals/100);
	newLine();
	*/
	
	if(decimalPlaces > 0){
		*--s = (decimals % 10) + '0';
		decimals /= 10; // repeat for as many decimal places as you need
		if(decimalPlaces >1){
			*--s = (decimals % 10) + '0';
			decimals /= 10;
			if(decimalPlaces > 2){
				*--s = (decimals % 10) + '0';
				decimals /= 10;
				if(decimalPlaces > 3){
					*--s = (decimals % 10) + '0';
					decimals /= 10;
				}
			}
		}
		*--s = '.';
	}else{
		//add 1 zero to the end.		
		*--s = '\0'+'0';
		*--s = '.';
	}
	
	

	while (units > 0) {
		*--s = (units % 10) + '0';
		units /= 10;
	}
	if (x < 0) *--s = '-'; // unary minus sign for negative numbers
	if(x == 0){*--s = '\0'+'0';}
	return s;
}
